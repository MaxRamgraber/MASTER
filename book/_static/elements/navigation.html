<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>D3.js Dynamic Graph from References and Tags</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Helvetica, sans-serif;
    }
    svg {
      position: absolute;
      top: 0;
      left: 0;
    }
    .link { stroke: #999; stroke-opacity: 0.6; stroke-width: 2px; }
    .node { cursor: pointer; stroke: #fff; stroke-width: 1.5px; }
    .label { font-size: 12px; pointer-events: none; }
    .hull { stroke: #999; stroke-width: 1px; opacity: 0.3; }
  </style>
</head>
<body>

<svg id="graph"></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<!-- All application logic is now an ESâ€‘module so we can import graphData.js -->
<script type="module">
import { loadGraphData } from './graphData.js';

// ----------------------------------
// 1) Setup SVG and container
// ----------------------------------
const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
const width   = vw;
const height  = vh;
const maxdim  = Math.max(width, height);

const svg = d3.select("#graph")
  .attr("width",  width)
  .attr("height", height);

// Containers: one for hulls, one for everything else
const container  = svg.append("g");
const hullGroup  = container.append("g").attr("class", "hullLayer");
const gContainer = container.append("g");

// ----------------------------------
// 2) Zoom behaviour (with transform persistence)
// ----------------------------------
const zoom = d3.zoom()
  .extent([[0, 0], [width, height]])
  .scaleExtent([0.5, 5])
  .on("zoom", event => {
    container.attr("transform", event.transform);
    sessionStorage.setItem('graphTransform', JSON.stringify(event.transform));
  });

const savedTransform = sessionStorage.getItem('graphTransform');

// ----------------------------------
// 3) Helper functions + styling data (unchanged)
// ----------------------------------
function capitalizeWords(str) {
  return str.replace(/\b\w/g, char => char.toUpperCase());
}
function extractTitle(filename) {
  return capitalizeWords(filename.replace('.md', '').replace(/_/g, ' '));
}

const visualMargin = maxdim * 0.025;
const groupColors = {
  "linear algebra": "#ff8888",
  "statistics":     "#88ff88"
  // extend as needed
};

function computeExpandedHull(groupNodes, margin) {
  if (groupNodes.length < 3) return null;
  const step = Math.PI / 36;
  const pts  = [];
  groupNodes.forEach(d => {
    for (let a = 0; a < 2 * Math.PI; a += step) {
      pts.push([d.x + margin * Math.cos(a), d.y + margin * Math.sin(a)]);
    }
  });
  return d3.polygonHull(pts);
}

// ----------------------------------
// 4) Persist node positions (unchanged)
// ----------------------------------
function saveNodePositions(nodes) {
  sessionStorage.setItem('nodePositions', JSON.stringify(nodes.map(n => ({ id:n.id,x:n.x,y:n.y,fx:n.fx,fy:n.fy }))));
}
function restoreNodePositions(nodes) {
  const saved = sessionStorage.getItem('nodePositions');
  if (!saved) return false;
  try {
    const posMap = new Map(JSON.parse(saved).map(p => [p.id, p]));
    let restored = 0;
    nodes.forEach(n => {
      const p = posMap.get(n.id);
      if (p) { n.x=p.x; n.y=p.y; n.fx=p.fx; n.fy=p.fy; restored++; }
    });
    return restored > 0;
  } catch { return false; }
}

// ----------------------------------
// 5) Fetch + parse references/tags (moved to graphData.js)
// ----------------------------------
loadGraphData(maxdim).then(({ nodes, links }) => {
 
  // ----------------------------------
  // 6) Optionally restore positions
  // ----------------------------------
  const hadSavedPositions = restoreNodePositions(nodes);

  // Force simulation
  const simulation = d3.forceSimulation(nodes)
    .force("link",   d3.forceLink(links).id(d => d.id).distance(maxdim * 0.1))
    .force("charge", d3.forceManyBody().strength(-maxdim/2).distanceMax(maxdim*0.25))
    .force("center", d3.forceCenter(width/2, height/2).strength(0.1))
    .on("tick", ticked)
    .on("end", () => saveNodePositions(nodes));

  if (hadSavedPositions) simulation.alpha(0.3).restart();

  // ----------------------------------
  // 7) Draw links, nodes, labels
  // ----------------------------------
  const link = gContainer.selectAll(".link")
    .data(links)
    .enter().append("line")
    .attr("class", "link");

  const node = gContainer.selectAll(".node")
    .data(nodes)
    .enter().append("circle")
    .attr("class", d => {
      let cls = "node";
      if (d.tag) cls += " " + d.tag.toLowerCase().replace(/\s+/g, '-');
      return cls;
    })
    .attr("r", d => d.radius)
    .style("fill", d => d.tag ? (groupColors[d.tag.toLowerCase()] || "#ccc") : "#ccc")
    .call(d3.drag()
      .on("start", dragStarted)
      .on("drag", dragged)
      .on("end",  dragEnded))
    .on("click", (e,d) => { if (d.link) window.open(d.link, "_top"); });

  const label = gContainer.selectAll(".label")
    .data(nodes)
    .enter().append("text")
    .attr("class", "label")
    .attr("text-anchor", "middle")
    .style("font-size", (maxdim*0.01)+"px")
    .attr("dy", d => -d.radius - 5)
    .text(d => d.text);

  // tick handler updates positions & hulls
  function ticked() {
    link
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);

    node
      .attr("cx", d => d.x)
      .attr("cy", d => d.y);

    label
      .attr("x", d => d.x)
      .attr("y", d => d.y);

    // Hulls per tag
    const groups = d3.group(nodes.filter(d=>d.tag), d=>d.tag);
    const hullData = [];
    groups.forEach((gn, tag) => {
      if (gn.length >= 3) {
        const hull = computeExpandedHull(gn, visualMargin);
        if (hull) hullData.push({ tag, hull });
      }
    });

    const hullPaths = hullGroup.selectAll("path").data(hullData, d => d.tag);

    hullPaths.enter().append("path")
      .attr("class", d => "hull " + d.tag.toLowerCase().replace(/\s+/g,'-'))
      .merge(hullPaths)
      .attr("d", d => "M"+d.hull.join("L")+"Z")
      .style("fill", d => groupColors[d.tag.toLowerCase()] || "#ccc")
      .style("stroke", "#999")
      .style("opacity", 0.3);

    hullPaths.exit().remove();
  }

  // Drag handlers
  function dragStarted(event,d) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x; d.fy = d.y;
  }
  function dragged(event,d) { d.fx = event.x; d.fy = event.y; }
  function dragEnded(event,d) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = null; d.fy = null;
    saveNodePositions(nodes);
  }

  // ----------------------------------
  // 8) Apply stored zoom transform
  // ----------------------------------
  svg.call(zoom);
  if (savedTransform) {
    try {
      const t = JSON.parse(savedTransform);
      svg.call(zoom.transform, d3.zoomIdentity.translate(t.x, t.y).scale(t.k));
    } catch {}
  }

}).catch(err => console.error('Failed to load graph data:', err));

</script>
</body>
</html>
