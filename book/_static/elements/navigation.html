<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>D3.js Graph - Start Positions & Percent Distances</title>
  <style>
    body {
      margin: 0; 
      overflow: hidden;
      font-family: Helvetica, sans-serif;
    }
    .my_datavizdiv {
      position: absolute;
      margin: 0; 
      overflow: hidden;
    }
    svg {
      position: absolute;
      top: 0;
      left: 0;
      margin: 0; 
      overflow: hidden;
    }
    .link { stroke: #999; stroke-opacity: 0.6; stroke-width: 2px; }
    .node { cursor: pointer; stroke: #fff; stroke-width: 1.5px; }
    .label { font-size: 12px; pointer-events: none; }
  </style>
</head>
<body>

<svg id="graph"></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
  // 1) Compute width & height
  const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
  const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
  const aspect = 2;
  let width, height;
  if (vw / aspect < vh) {
    width = vw;
    height = vw / aspect;
  } else {
    width = vh * aspect;
    height = vh;
  }

  const svg = d3.select("#graph")
    .attr("width", width)
    .attr("height", height);

  // Create a container <g> that we'll pan/zoom
  const gContainer = svg.append("g");

  // 2) Graph data
  const graphData = {
    nodes: [
      { id: "1", text: "Linear Algebra", xPct: 0.50, yPct: 0.50, radiusPct: 0.05, pinned: true, link: "../linear_algebra.html"},
      { id: "2", text: "Matrix Multiplication", xPct: 0.25, yPct: 0.30, radiusPct: 0.03, link: "../matrix_multiplication.html" },
      { id: "3", text: "Linear Regression", xPct: 0.80, yPct: 0.40, radiusPct: 0.03, link: "../linear_regression.html"}
    ],
    links: [
      { source: "1", target: "2" },
      { source: "1", target: "3" },
    ]
  };

  // Convert percentages to actual pixels
  graphData.nodes.forEach(d => {
    d.x = d.xPct * width;
    d.y = d.yPct * height;
    d.radius = d.radiusPct * height;
    if (d.pinned) {
      d.fx = d.x;
      d.fy = d.y;
    }
  });

  // 3) Forces
  const linkDistance = 0.15 * height;
  const chargeStrength = -0.3 * height;

  const simulation = d3.forceSimulation(graphData.nodes)
    .force("link", d3.forceLink(graphData.links).id(d => d.id).distance(linkDistance))
    .force("charge", d3.forceManyBody().strength(chargeStrength))
    .force("collision", d3.forceCollide().radius(d => d.radius))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .on("tick", ticked);

  // 4) Draw links, nodes, labels inside gContainer
  const link = gContainer.selectAll(".link")
    .data(graphData.links)
    .enter()
    .append("line")
    .attr("class", "link");

  const node = gContainer.selectAll(".node")
    .data(graphData.nodes)
    .enter()
    .append("circle")
    .attr("class", "node")
    .attr("r", d => d.radius)
    .style("fill", (d, i) => d3.schemeTableau10[i % 10])
    .call(drag(simulation)) 
    .on("click", (event, d) => {
      if (d.link) window.open(d.link, "_blank");
    });

  const label = gContainer.selectAll(".label")
    .data(graphData.nodes)
    .enter()
    .append("text")
    .attr("class", "label")
    .attr("text-anchor", "middle")
    .attr("dy", d => d.radius / 10)
    .text(d => d.text);

  function ticked() {
    link
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);

    node
      .attr("cx", d => d.x)
      .attr("cy", d => d.y);

    label
      .attr("x", d => d.x)
      .attr("y", d => d.y);
  }

  // 5) Drag behavior for nodes
  function drag(simulation) {
    function dragStarted(event, d) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x; d.fy = d.y;
    }
    function dragged(event, d) {
      d.fx = event.x; d.fy = event.y;
    }
    function dragEnded(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      if (!d.pinned) { d.fx = null; d.fy = null; }
    }
    return d3.drag()
      .on("start", dragStarted)
      .on("drag", dragged)
      .on("end", dragEnded);
  }

  // 6) Zoom + pan on the whole graph
  svg.call(d3.zoom()
    .extent([[0, 0], [width, height]])
    .scaleExtent([0.5, 5])      // Adjust as desired for zoom limits
    .on("zoom", (event) => {
      gContainer.attr("transform", event.transform);
    })
  );
</script>
</body>
</html>
