<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>D3.js Dynamic Graph from References and Tags</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Helvetica, sans-serif;
    }
    svg {
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
</head>
<body>

<svg id="graph"></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script type="module">
// ----------------------------------
// 1) Setup SVG and container
// ----------------------------------
const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
const width = vw;
const height = vh;
const maxdim = Math.max(width, height);

const svg = d3.select("#graph").attr("width", width).attr("height", height);

// Create a common container for both hulls and the rest of the graph.
const container = svg.append("g");
// Hulls will be rendered in this layer (behind nodes).
const hullGroup = container.append("g").attr("class", "hullLayer");
// Nodes, links, and labels will be rendered here.
const gContainer = container.append("g");

// ----------------------------------
// 2) Helper functions & styling
// ----------------------------------
const groupColors = {
  physics: "#1f77b4",
  math: "#ff7f0e",
  cs: "#2ca02c",
  default: "#7f7f7f",
};

function restoreNodePositions(nodes) {
  // Retrieve saved positions from localStorage
  const saved = localStorage.getItem("nodePositions");
  if (!saved) return false;
  try {
    const savedPositions = JSON.parse(saved);
    let restoredCount = 0;
    nodes.forEach(n => {
      const id = n.id || n.name;
      if (savedPositions[id]) {
        const s = savedPositions[id];
        n.fx = s.x;
        n.fy = s.y;
        restoredCount++;
      }
    });
    return restoredCount > 0;
  } catch (err) {
    console.warn("Failed to parse node positions:", err);
    return false;
  }
}

function saveNodePositions(nodes) {
  const positions = {};
  nodes.forEach(n => {
    positions[n.id || n.name] = { x: n.x, y: n.y };
  });
  localStorage.setItem("nodePositions", JSON.stringify(positions));
}

// ----------------------------------
// 3) Load data with helper module
// ----------------------------------
import { loadGraphData } from './graphData.js';

loadGraphData(maxdim).then(({ nodes, links }) => {
// 6) Optionally restore positions so the sim starts from the latest known state
  const hadSavedPositions = restoreNodePositions(nodes);

  // Create the simulation
  const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d => d.id).distance(maxdim * 0.1))
    .force("charge", d3.forceManyBody().strength(-maxdim / 2).distanceMax(maxdim * 0.25))
    .force("center", d3.forceCenter(width / 2, height / 2).strength(0.1))
    .on("tick", ticked)
    .on("end", () => saveNodePositions(nodes));

  if (hadSavedPositions) simulation.alpha(0.3).restart();

  // --- Build links, nodes, labels, drag handlers, hulls, etc. ---
  const link = gContainer.append("g")
    .attr("stroke", "#aaa")
    .selectAll("line")
    .data(links)
    .enter().append("line")
    .attr("stroke-width", 1.5);

  const node = gContainer.append("g")
    .selectAll("circle")
    .data(nodes)
    .enter().append("circle")
    .attr("r", d => d.radius)
    .attr("fill", d => groupColors[d.tag?.toLowerCase()] || groupColors.default)
    .call(d3.drag()
      .on("start", dragStarted)
      .on("drag", dragged)
      .on("end", dragEnded));

  const label = gContainer.append("g")
    .selectAll("text")
    .data(nodes)
    .enter().append("text")
    .text(d => d.text)
    .attr("dy", 4)
    .attr("text-anchor", "middle")
    .style("pointer-events", "none");

  function ticked() {
    link
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);

    node
      .attr("cx", d => d.x)
      .attr("cy", d => d.y);

    label
      .attr("x", d => d.x)
      .attr("y", d => d.y);

    // --- Hull rendering (optional) ---
    const hullPaths = hullGroup.selectAll("path")
      .data([]) // placeholder if you maintain hulls
      .join("path");

    hullPaths.exit().remove();
  }

  // --- Drag handlers ---
  function dragStarted(event, d) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }

  function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
  }

  function dragEnded(event, d) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }

  // --- Zoom behaviour & persisted transform ---
  const zoom = d3.zoom().scaleExtent([0.1, 8]).on("zoom", (event) => {
    gContainer.attr("transform", event.transform);
  });
  svg.call(zoom);

  const savedTransform = localStorage.getItem("zoomTransform");
  if (savedTransform) {
    try {
      const t = JSON.parse(savedTransform);
      const restored = d3.zoomIdentity.translate(t.x, t.y).scale(t.k);
      svg.call(zoom.transform, restored);
    } catch (err) {
      console.warn("Could not parse saved zoom transform:", err);
    }
  }
}).catch(err => console.error('Failed to load graph data:', err));

</script>

</body>
</html>
