<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>D3.js Dynamic Graph from References and Tags</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Helvetica, sans-serif;
    }
    svg {
      position: absolute;
      top: 0;
      left: 0;
    }
    .link { stroke: #999; stroke-opacity: 0.6; stroke-width: 2px; }
    .node { cursor: pointer; stroke: #fff; stroke-width: 1.5px; }
    .label { font-size: 12px; pointer-events: none; }
    /* Hull styling is now set dynamically, but default styles are provided: */
    .hull {
      stroke: #999;
      stroke-width: 1px;
      opacity: 0.3;
    }
  </style>
</head>
<body>

<svg id="graph"></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
  const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
  const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
  const width = vw;
  const height = vh;

  const svg = d3.select("#graph").attr("width", width).attr("height", height);
  
  // Create a group for hulls behind other elements.
  const hullGroup = svg.insert("g", ":first-child").attr("class", "hullLayer");
  // Container for links, nodes, and labels.
  const gContainer = svg.append("g");

  function capitalizeWords(str) {
    return str.replace(/\b\w/g, char => char.toUpperCase());
  }
  function extractTitle(filename) {
    return capitalizeWords(filename.replace('.md', '').replace(/_/g, ' '));
  }

  // Margin for hull expansion.
  const visualMargin = 15;

  // Dummy dictionary mapping tag values (in lowercase) to colors.
  const groupColors = {
    "linear algebra": "#ff8888",  // light red
    "statistics": "#88ff88",      // light green
    // Add additional mappings as needed.
  };

  // Utility: Compute an expanded convex hull for a set of nodes given a margin.
  function computeExpandedHull(groupNodes, margin) {
    if (groupNodes.length < 3) return null;
    const step = Math.PI / 6;
    const expandedPoints = [];
    groupNodes.forEach(d => {
      for (let angle = 0; angle < 2 * Math.PI; angle += step) {
        const x = d.x + margin * Math.cos(angle);
        const y = d.y + margin * Math.sin(angle);
        expandedPoints.push([x, y]);
      }
    });
    return d3.polygonHull(expandedPoints);
  }

  // Fetch both references.txt and tags.txt.
  Promise.all([
    fetch('https://maxramgraber.github.io/MASTER/main/references.txt').then(response => response.text()),
    fetch('https://maxramgraber.github.io/MASTER/main/tags.txt').then(response => response.text())
  ])
  .then(([refData, tagData]) => {
    // Parse tags.txt into a map: filename -> tag.
    const tagMap = new Map();
    tagData.trim().split('\n').forEach(line => {
      // Expected format: "filename.md -> [tag: 'tag value']"
      const m = line.match(/^(.*?) -> \[tag:\s*'(.*?)'\]$/);
      if (m) {
        tagMap.set(m[1].trim(), m[2].trim());
      }
    });
    
    // Parse references.txt.
    const lines = refData.trim().split('\n');
    const nodesMap = new Map();
    const links = [];
    const referenceCounts = new Map();

    lines.forEach(line => {
      // Expected format: "source.md -> [text: 'Display'] [target: 'target']"
      const match = line.match(/^(.*?) -> \[text: '(.*?)'\] \[target: '(.*?)'\]$/);
      if (match) {
        const sourceFile = match[1].trim();
        const displayText = match[2].trim();
        const target = match[3].trim();

        if (!nodesMap.has(sourceFile)) {
          nodesMap.set(sourceFile, { id: sourceFile, text: extractTitle(sourceFile), link: `https://maxramgraber.github.io/MASTER/main/pages/${sourceFile.replace('.md', '.html')}` });
        }
        if (!nodesMap.has(target + '.md')) {
          nodesMap.set(target + '.md', { id: target + '.md', text: extractTitle(target), link: `https://maxramgraber.github.io/MASTER/main/pages/${target}.html` });
        }

        links.push({ source: sourceFile, target: target + '.md' });

        referenceCounts.set(target + '.md', (referenceCounts.get(target + '.md') || 0) + 1);
        referenceCounts.set(sourceFile, (referenceCounts.get(sourceFile) || 0) + 1);
      }
    });

    const nodes = Array.from(nodesMap.values());
    // Add tag property to nodes if available.
    nodes.forEach(node => {
      if (tagMap.has(node.id)) {
        node.tag = tagMap.get(node.id);
      }
    });

    const minRadius = height * 0.02, maxRadius = height * 0.02;
    const maxReferences = 10;
    nodes.forEach(node => {
      const count = referenceCounts.get(node.id) || 0;
      node.radius = minRadius + (maxRadius - minRadius) * Math.min(count / maxReferences, 1);
    });

    // Create the simulation.
    const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id).distance(height * 0.1))
      .force("charge", d3.forceManyBody().strength(-height / 2).distanceMax(height * 0.2))
      .force("center", d3.forceCenter(width / 2, height / 2).strength(0.1))
      .on("tick", ticked);

    const link = gContainer.selectAll(".link")
      .data(links)
      .enter()
      .append("line")
      .attr("class", "link");

    // Create nodes; if a node has a tag, use the color from groupColors, else gray.
    const node = gContainer.selectAll(".node")
      .data(nodes)
      .enter()
      .append("circle")
      .attr("class", d => {
         let classes = "node";
         if (d.tag) {
           const tagClass = d.tag.toLowerCase().replace(/\s+/g, '-');
           classes += " " + tagClass;
         }
         return classes;
      })
      .attr("r", d => d.radius)
      .style("fill", d => {
         if (d.tag) {
           return groupColors[d.tag.toLowerCase()] || "#ccc";
         } else {
           return "#ccc";
         }
      })
      .call(d3.drag()
        .on("start", dragStarted)
        .on("drag", dragged)
        .on("end", dragEnded))
      .on("click", (event, d) => {
        if (d.link) window.open(d.link, "_blank");
      });

    const label = gContainer.selectAll(".label")
      .data(nodes)
      .enter()
      .append("text")
      .style("font-size", (height * 0.02) + "px")
      .attr("class", "label")
      .attr("text-anchor", "middle")
      .attr("dy", d => -d.radius - 5)
      .text(d => d.text);

    function ticked() {
      link.attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

      node.attr("cx", d => d.x)
          .attr("cy", d => d.y);

      label.attr("x", d => d.x)
           .attr("y", d => d.y);
      
      // --- Compute and render hulls for each tag group ---
      const groups = d3.group(nodes.filter(d => d.tag), d => d.tag);
      const hullData = [];
      groups.forEach((groupNodes, tag) => {
         if (groupNodes.length >= 3) {
           const hull = computeExpandedHull(groupNodes, visualMargin);
           if (hull) {
             hullData.push({ tag: tag, hull: hull });
           }
         }
      });
      
      const hullPaths = hullGroup.selectAll("path")
          .data(hullData, d => d.tag);
      
      hullPaths.enter()
          .append("path")
          .attr("class", d => "hull " + d.tag.toLowerCase().replace(/\s+/g, "-"))
          .merge(hullPaths)
          .attr("d", d => "M" + d.hull.join("L") + "Z")
          .style("fill", d => groupColors[d.tag.toLowerCase()] || "#ccc")
          .style("stroke", "#999")
          .style("opacity", 0.3);
      
      hullPaths.exit().remove();
      // --- End hull rendering ---
    }

    function dragStarted(event, d) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }
    function dragged(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }
    function dragEnded(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }

    svg.call(d3.zoom()
      .extent([[0, 0], [width, height]])
      .scaleExtent([0.5, 5])
      .on("zoom", (event) => gContainer.attr("transform", event.transform))
    );
  })
  .catch(err => console.error('Failed to load references or tags:', err));
</script>

</body>
</html>
